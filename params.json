{"name":"Quicksnap","body":"# quicksnap\r\n\r\nQuicksnap is a simple clojure state machine. The idea is that you can define a path for each state to travel along as a flow definition, then define which functions contain the logic for each of the states to prgress it to the next state. \r\n\r\nThis idea splits up the notion of the flow graph from the functions that will be involved in actually performing the work.\r\n\r\n## Usage\r\n\r\nA simple robot that goes from initial (off?) state, then spins from red to green until it has changed 10 times can be written as follows :\r\n\r\nFirst, we can define our flow as\r\n\r\n```clojure\r\n(def robot-flow\r\n  (flow\r\n   :start [\"initialize\" :next :red]\r\n   :red [\"next\" :next :orange]\r\n   :orange [\"next\" :next :green]\r\n   :green [\"next\" :next :red]))\r\n```\r\n\r\nThis flow will start at :start as you can imagine, then will bind the :next step to :red and call the function bound to \"initialize\" (currently unknown). :start will then proceed to :red, :red to :orange, :orange to :green and :green to :red, ad infinitum.\r\n\r\nLet's demonstrate setting up our robot\r\n\r\n```clojure\r\n(defn init-robot [statename {next-fn :next} session]\r\n  (println \"Initialize Robot\")\r\n  (next-fn (assoc session :state \"Started\" :cnt 0)))\r\n```\r\n\r\nNot much to it, we accept the current state name, a map of functions to call in order to move forward and a session map that we can modify and pass on to the next function. We'll use the session to keep track of our last state and the change count.\r\n\r\nNext up, we need a function for changing the light:\r\n\r\n```clojure\r\n(defn change-light [statename {next-fn :next} {cnt :cnt state :state :as session}]\r\n  (println \"Next\" statename \", from state:\" state)\r\n  (if (< cnt 10)\r\n    (next-fn (assoc session :state statename :cnt (inc cnt)))))\r\n```\r\n\r\nHere, again, we accept current state, the next functions and destructure our session to use it in our logic.\r\n\r\nNow we've got all the pieces.. except the mapping for the flow functions of \"initialize\" and \"next\". Straightforward:\r\n\r\n```clojure\r\n(def robot-fns\r\n  (state-fns\r\n   \"initialize\" #'init-robot\r\n   \"next\" #'change-light))\r\n```\r\n\r\nA fairly simple binding in this case. The reason for this extra binding step is that it is useful in case your function calls are anonymous or partial kung-fu calls. Mixing that directly into the flow detracts from the flow definition's purpose. \r\n\r\nNow we run the machine with a call to\r\n```clojure\r\n(run-machine robot-fns robot-flow)\r\n```\r\n\r\nAnd we get our result:\r\n```\r\nInitialize Robot\r\nNext :red , old state: Started\r\nNext :orange , old state: :red\r\nNext :green , old state: :orange\r\nNext :red , old state: :green\r\nNext :orange , old state: :red\r\nNext :green , old state: :orange\r\nNext :red , old state: :green\r\nNext :orange , old state: :red\r\nNext :green , old state: :orange\r\nNext :red , old state: :green\r\nNext :orange , old state: :red\r\n```\r\n\r\nI'll leave making it switch state from red -> orange -> green -> red as an exercise to you :)\r\n\r\nNotice that you can have multiple outcomes for each state :\r\n\r\n```clojure\r\n(def robot-flow\r\n  (flow\r\n   :start [\"initialize\" :next :red]\r\n   :red [\"next\"\r\n         :next :orange\r\n         :finished :done]\r\n   :orange [\"next\"\r\n            :next :green\r\n            :finished :done]\r\n   :green [\"next\"\r\n           :next :red\r\n           :finished :done]\r\n   :done [\"finished\"]))\r\n```\r\n\r\nCheck the quicksnap/sample.clj for the rest of the implementation for this.\r\n\r\n*Please note:* This example blows the stack. I'm trying to decide how to handle the stack gracefully, so any input is welcome! My first thought was to use trampoline, but I'm not enitrely convinced this is how it should be done...\r\n\r\n## License\r\n\r\nCopyright (C) 2012 Yuppiechef (pty) ltd.\r\n\r\nDistributed under the Eclipse Public License, the same as Clojure.\r\n","tagline":"Quicksnap is a simple clojure state machine","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}